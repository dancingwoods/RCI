\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `RCI'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Title]\AsIs{R Calcium Imaging Analysis}
\item[Version]\AsIs{1.0}
\item[Date]\AsIs{2010-01-09}
\item[Author]\AsIs{Bronwyn Woods}
\item[Maintainer]\AsIs{Bronwyn Woods }\email{bwoods@cmu.edu}\AsIs{}
\item[Description]\AsIs{Tools for analyzing in-vivo two-photon calcium imaging data.}
\item[License]\AsIs{GPL}
\item[Depends]\AsIs{R (>= 2.14.0)}
\item[Imports]\AsIs{RSQLite, randomForest, gWidgets, gWidgetsRGtk2, cairoDevice,
R.utils, mgcv, RSEIS, igraph}
\item[Collate]\AsIs{'datainport.R' 'motion.R' 'plotting.R' 'segmentation.R'
'gui.R' 'imageprocessing.R' 'timeseries.R' 'clustering.R'
'classifier.R'}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{AddConMat}{INTERNAL Adds the overlap edges to a mask database}{AddConMat}
%
\begin{Description}\relax
INTERNAL Adds the overlap edges to a mask database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  AddConMat(db, cmat, ids)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database object

\item[\code{cmat}] a matrix of 0/1 values giving the locations
of edges between masks

\item[\code{ids}] a vector giving the ids of the masks in cmat
(in order)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{AddMask}{Plots a mask over an already plotted image}{AddMask}
%
\begin{Description}\relax
Plots a mask over an already plotted image
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  AddMask(mask, rgb = runif(3), alpha = 0.5, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mask}] the specification of the mask

\item[\code{rgb}] a vector of length 3 giving the color of the
mask in RGB (defaults to random)

\item[\code{alpha}] the alpha transparency value of the mask
(between 0 and 1)

\item[\code{...}] additional graphing parameters
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a mask as either a matrix of logicals or a matrix
with 1's on the mask, over-plot a semi-transparent
colored region on an already plotted image.
\end{Details}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{AddMaskConnections}{INTERNAL Adds the overlap edges to a mask database}{AddMaskConnections}
%
\begin{Description}\relax
INTERNAL Adds the overlap edges to a mask database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  AddMaskConnections(db)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database object
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{AddMasks}{Generate masks according to the given method and add them to the database}{AddMasks}
%
\begin{Description}\relax
Generate masks according to the given method and add them
to the database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  AddMasks(db, calexp, method, channel = 2, scales = NULL,
    invert = F)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database object

\item[\code{calexp}] the calcium experiment data object

\item[\code{method}] what method should be used to generate
masks to add. 'LoG' Laplacian of Gaussian, EqThresh
thresholding of equalized image

\item[\code{channel}] which data channel to use for computing
the masks

\item[\code{scales}] which smoothing scales to use for method
(LoG)

\item[\code{invert}] boolean, should the mean image be inverted
to find dark regions instead of bright?
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{AddMaskSet}{Plots sets of masks over an already plotted image}{AddMaskSet}
%
\begin{Description}\relax
Plots sets of masks over an already plotted image
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  AddMaskSet(mask, alpha = 0.5, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mask}] the specification of the mask, unique values
for each mask set, and 0 or NA in background

\item[\code{alpha}] the alpha transparency value of the mask
(between 0 and 1)

\item[\code{...}] additional graphing parameters
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a matrix with unique integers for each mask set,
overplot each mask set in a different color (randomly
chosen)
\end{Details}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{AssignContiguous}{Assigns the non-zero pixels of 'region' to one contiguous (cardinal directions) regions}{AssignContiguous}
%
\begin{Description}\relax
Assigns the non-zero pixels of 'region' to one contiguous
(cardinal directions) regions
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  AssignContiguous(region)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{region}] a matrix with 1 in the regions to be
assigned and 0 elsewhere
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with unique integers in the pixels of each
region
\end{Value}
\inputencoding{utf8}
\HeaderA{AssignToPeaks}{Assigns the non-zero pixels of 'region' to one of the maxima of the image by hillclimbing on image}{AssignToPeaks}
%
\begin{Description}\relax
Assigns the non-zero pixels of 'region' to one of the
maxima of the image by hillclimbing on image
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  AssignToPeaks(region, image, restrict = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{region}] a matrix with 1 in the regions to be
assigned and 0 elsewhere

\item[\code{image}] the image matrix

\item[\code{restrict}] boolean.  should the hill-climbing be
restricted to a path entirely within region
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with unique integers in the pixels of region
corresponding to each local maxima
\end{Value}
\inputencoding{utf8}
\HeaderA{ClipImage}{Clips a border from around an image matrix}{ClipImage}
%
\begin{Description}\relax
Clips a border from around an image matrix
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ClipImage(image, border = NULL, size = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{image}] the image matrix to clip

\item[\code{border}] the size of the border to clip.  Must be
less than half the image size

\item[\code{size}] the resulting size of the image.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
uses the size argument if given, else uses the border
argument, else returns the original image
\end{Details}
%
\begin{Value}
a matrix with the center (nrow-2*border) by
(ncol-2*border) pixels of the image
\end{Value}
\inputencoding{utf8}
\HeaderA{ClustDistance}{Return the corrected Rand index for the two given clusterings}{ClustDistance}
%
\begin{Description}\relax
Return the corrected Rand index for the two given
clusterings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ClustDistance(clust, clust2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{clust}] a vector giving the first clustering

\item[\code{clust2}] a vector giving the second clustering
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the corrected Rand index value
\end{Value}
\inputencoding{utf8}
\HeaderA{ClusterCells}{Cluster segmented ROIs based on correlation or phase distance using k-means}{ClusterCells}
%
\begin{Description}\relax
Cluster segmented ROIs based on correlation or phase
distance using k-means
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ClusterCells(calexp, mask, k, criteria = "cor",
    freq = c(0.78, 0.81), dt = 0.1247232)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{calexp}] the calexp object with the data

\item[\code{mask}] a mask identifying the cells to be clustered.
Each unique non-zero/NA value in the mask indicates a
cell to be clustered.

\item[\code{k}] the number of clusters to find

\item[\code{criteria}] the criteria to use for clustering --
'cor' (correlation) 'phase' (phase of frequency specified
in freq)

\item[\code{freq}] the frequency band to use to extract the
phase for phase-clustering
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{ClusterCorrelation}{See correlation with clusters}{ClusterCorrelation}
%
\begin{Description}\relax
See correlation with clusters
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ClusterCorrelation(calexp, clusters)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{calexp}] the calexp object

\item[\code{clusters}] the cluster object as returned from
ClusterCells
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{CompMaskC}{INTERNAL Compute the overlap of a single mask with a list of masks}{CompMaskC}
%
\begin{Description}\relax
INTERNAL Compute the overlap of a single mask with a list
of masks
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CompMaskC(mask, masklist)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mask}] A single mask formatted as a vector of mask
indices with or without the negative id as the first
element of the vector.

\item[\code{masklist}] A list of sparse masks as returned by
GetMasks.  Each element of this list is a vector whose
first element is the negative id of the mask and whose
other elements are the sorted indices of the mask
pixels.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Computes the overlap matrix between a mask and a list of
other masks using C code for efficiency
\end{Details}
%
\begin{Value}
a vector whose elements are 0 or 1 giving the overlap
relationships between the masks.  The values are sorted
in the vector in the same order as they are given in
masklist.
\end{Value}
\inputencoding{utf8}
\HeaderA{CompMasksC}{INTERNAL Compute the overlap matrix between a set of masks}{CompMasksC}
%
\begin{Description}\relax
INTERNAL Compute the overlap matrix between a set of
masks
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CompMasksC(masklist)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{masklist}] A list of sparse masks.  Each element of
this list is a vector whose first element is the negative
id of the mask and whose other elements are the sorted
indices of the mask pixels.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Computes the overlap matrix between a set of masks using
C code for efficiency.
\end{Details}
%
\begin{Value}
a matrix whose elements are 0 or 1 giving the overlap
relationships between the masks.  The masks are sorted in
the matrix in the same order as they are given in
masklist.
\end{Value}
\inputencoding{utf8}
\HeaderA{ComputeMaskFeatures}{Computed features of masks that are currently in the mask database. This is sort of hack - should be more general and allow users to specify feature functions}{ComputeMaskFeatures}
%
\begin{Description}\relax
Computed features of masks that are currently in the mask
database. This is sort of hack - should be more general
and allow users to specify feature functions
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ComputeMaskFeatures(db, calexp, feature)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database object

\item[\code{calexp}] the calcium experiment object

\item[\code{feature}] string indicating which feature to
compute
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Current feature options: "size" - mask size in pixels
\end{Details}
\inputencoding{utf8}
\HeaderA{ConMaskDb}{Connects to an experiment's mask database}{ConMaskDb}
%
\begin{Description}\relax
Connects to an experiment's mask database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ConMaskDb(path)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] the path to the SQLite database to connect
to
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a connection object as returned by dbConnect in the DBI
package
\end{Value}
\inputencoding{utf8}
\HeaderA{ConvolveImage}{Convolves an image with the given kernel matrix}{ConvolveImage}
%
\begin{Description}\relax
Convolves an image with the given kernel matrix
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ConvolveImage(image, kernel, circular = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{image}] a matrix with the image

\item[\code{kernel}] a matrix with the kernel (should be smaller
than the image)

\item[\code{circular}] boolean, should the convolution be
circular (default) or should the image be padded with
zeros to prevent circular convolution
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses Fourier methods to convolve the given image with the
given kernel
\end{Details}
%
\begin{Value}
a matrix of the same size as image with the convolved
image
\end{Value}
\inputencoding{utf8}
\HeaderA{CorByTime}{Return array specifying the correlation matrix for a sliding window of the data}{CorByTime}
%
\begin{Description}\relax
Return array specifying the correlation matrix for a
sliding window of the data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CorByTime(seriesmat, window = 500)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{seriesmat}] a matrix with the calcium traces on the
columns

\item[\code{window}] the size of the sliding window
\end{ldescription}
\end{Arguments}
%
\begin{Value}
an array with the first two dimensions giving the
correlation matrices and the third dimension indicating
the start time of the window
\end{Value}
\inputencoding{utf8}
\HeaderA{CountHolesC}{INTERNAL Counts the number of pixels not in a mask that are surrounded by at least 3 mask pixels}{CountHolesC}
%
\begin{Description}\relax
INTERNAL Counts the number of pixels not in a mask that
are surrounded by at least 3 mask pixels
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CountHolesC(sparsemask, nr, nc)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sparsemask}] the mask in which to count holes
(sparse vector)

\item[\code{nr}] number of rows

\item[\code{nc}] number of columns
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses C code from the file countholesC.c
\end{Details}
%
\begin{Value}
an integer giving the number of holes in the mask
\end{Value}
\inputencoding{utf8}
\HeaderA{CreateCalExpFromCSV}{Convert a folder of text images to a calexp data object}{CreateCalExpFromCSV}
%
\begin{Description}\relax
Convert a folder of text images to a calexp data object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CreateCalExpFromCSV(name, imgdir, nchans = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] a short name to identify this experiment

\item[\code{imgdir}] a string giving the directory path for the
directory containing the csv images

\item[\code{nchans}] the number of channels that exist in the
data
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function Converts a directory of csv text files into
a calexp data object in R. Assumes that the images are
individual csv text files and that they are
alphabetically in order by channel and then by time
index.  The directory must contain only these csv image
files. Each image must have the same dimensions, and
there must be the same number of images for each channel.
\end{Details}
%
\begin{Value}
an object of class calexp \begin{ldescription}
\item[\code{name}] the name passed in
as an argument to this function\item[\code{data}] an array
containing the image data, with dimensions
nchans-nrows-ncols
\end{ldescription}
\end{Value}
\inputencoding{utf8}
\HeaderA{CreateCalExpFromText}{Convert a folder of text images to a calexp data object}{CreateCalExpFromText}
%
\begin{Description}\relax
Convert a folder of text images to a calexp data object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CreateCalExpFromText(name, imgdir, nchans = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] a short name to identify this experiment

\item[\code{imgdir}] a string giving the directory path for the
directory containing the csv images

\item[\code{nchans}] the number of channels that exist in the
data
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function Converts a directory of text files into a
calexp data object in R. Assumes that the images are
individual text files and that they are alphabetically in
order by channel and then by time index.  The directory
must contain only these image files. Each image must have
the same dimensions, and there must be the same number of
images for each channel.
\end{Details}
%
\begin{Value}
an object of class calexp \begin{ldescription}
\item[\code{name}] the name passed in
as an argument to this function\item[\code{data}] an array
containing the image data, with dimensions
nchans-nrows-ncols
\end{ldescription}
\end{Value}
\inputencoding{utf8}
\HeaderA{CreateCurExp}{INTERNAL Create an object to store information about the currently selected experiment.}{CreateCurExp}
%
\begin{Description}\relax
INTERNAL Create an object to store information about the
currently selected experiment.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CreateCurExp()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
Creates a list that stores information about the
currently selected experiment.
\end{Details}
%
\begin{Value}
A list with fields to store information about the
experiment (initially empty) \begin{ldescription}
\item[\code{name}] the experiment
name\item[\code{data}] if loaded, the data object for this
object\item[\code{db}] the database connection for this
experiment\item[\code{nmasks}] the number of candidate masks
in the database for this experiment\item[\code{features}] the
tags of the features that exist in this database
\item[\code{sources}] the tage for the mask sources present in
this database\item[\code{selmat}] a matrix where the first
column is the ID of the mask and the second column gives
the annotation for the mask\item[\code{sms}] the list of
sparse masks for the experiment retreived from the
database with GetMasks()\item[\code{mimg1}] the matrix giving
the mean image for channel 1\item[\code{mimg2}] the matrix
giving the mean image for channel 2\item[\code{nx}] the number
of columns in the images for this experiment
\item[\code{ny}] the number of rows in the images
\end{ldescription}
\end{Value}
\inputencoding{utf8}
\HeaderA{CreateDbController}{INTERNAL Creates an empty database controller}{CreateDbController}
%
\begin{Description}\relax
INTERNAL Creates an empty database controller
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  CreateDbController()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
A database controller holds information about the
directories where the databases, data, classifiers, and
helper files are stored. \\{}
\end{Details}
%
\begin{Value}
A list \begin{ldescription}
\item[\code{db.directory}] the directory holding SQLite
databases\item[\code{data.directory}] the directory holding
data associated with each database.  each of these should
have a \bsl{}\$data element\item[\code{helper.directory}] the
directory in which to place helper files generated by the
GUI\item[\code{classifier.direcoty}] the directory that
contains the classifiers used in segmentation
\item[\code{expdf}] a data.frame in which to put information
about each experiment, currently empty
\end{ldescription}
\end{Value}
\inputencoding{utf8}
\HeaderA{DbAddMask}{Add a mask to a database}{DbAddMask}
%
\begin{Description}\relax
Add a mask to a database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  DbAddMask(db, mask, source)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] a database connection object

\item[\code{mask}] a matrix giving the mask to add to the
database (T/F, 0/1, or NA/1)

\item[\code{source}] a string giving the tag for the source of
the mask
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Adds the given mask to the database.  If the mask is
already in the database, increments the count for the
source of the mask (or adds a new count for a new source)
\end{Details}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{DbSetup}{INTERNAL Creates an empty mask database with the appropriate tables}{DbSetup}
%
\begin{Description}\relax
INTERNAL Creates an empty mask database with the
appropriate tables
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  DbSetup(db)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database object for which to create the
mask tables
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{EmbedAndTaperImage}{Embeds an image in a larger matrix of 0's and tapers the image edges using a Hanning window}{EmbedAndTaperImage}
%
\begin{Description}\relax
Embeds an image in a larger matrix of 0's and tapers the
image edges using a Hanning window
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  EmbedAndTaperImage(img, taperamt, size = NULL,
    border = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img}] the image to embed and taper

\item[\code{taperamt}] the width of the taper on the edges of
the image.  Must be less than or equal to half the image
width

\item[\code{border}] the width of the border of 0's to add
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
uses size if given, else uses border, else doesn't embed
\end{Details}
%
\begin{Value}
an image that has been embedded and tapered
\end{Value}
\inputencoding{utf8}
\HeaderA{EmbedImage}{Embeds an image matrix in a larger matrix with a border of 0's}{EmbedImage}
%
\begin{Description}\relax
Embeds an image matrix in a larger matrix with a border
of 0's
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  EmbedImage(image, border = NULL, size = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{image}] the image to embed

\item[\code{border}] the width of the border to add around the
edges

\item[\code{size}] the resulting size of the image - this must
be bigger than the dimensions of image
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
uses the size argument if given, else uses the border
argument, else returns the original image
\end{Details}
%
\begin{Value}
a matrix of size (nrow+2*border) by (ncol+ 2*border)
\end{Value}
\inputencoding{utf8}
\HeaderA{EqualThreshMasks}{Generates a set of masks using thresholding of the sliding histogram equalized version of an image}{EqualThreshMasks}
%
\begin{Description}\relax
Generates a set of masks using thresholding of the
sliding histogram equalized version of an image
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  EqualThreshMasks(image, thresh, radius = 8,
    fullmax = 4096, sparse = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{image}] the image to use to generate masks

\item[\code{thresh}] the threshold to use (pixels above thresh
in equalized image are found)

\item[\code{radius}] the radius for the window used for
equalization

\item[\code{fullmax}] the maximum value possible (for
equalization)

\item[\code{sparse}] boolean, should the function return sparse
masks instead of a matrix for plotting
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with unique integers at mask locations and 0 in
the background, or a a sparse masks object
\end{Value}
\inputencoding{utf8}
\HeaderA{EvaluateConfidence}{Computes several confidence measures on the segmentation in a database these include - number of masks returned by the classifier - min, max, and mean probability assigned by the classifier}{EvaluateConfidence}
%
\begin{Description}\relax
Computes several confidence measures on the segmentation
in a database these include - number of masks returned by
the classifier - min, max, and mean probability assigned
by the classifier
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  EvaluateConfidence(db, class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database for which to evaluate the
segmentation confidence.

\item[\code{class}] the classifier used to generate the
segmentation
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.frame with a row for each ROI and columns
specifying confidence measures
\end{Value}
\inputencoding{utf8}
\HeaderA{EvaluateSegmentation}{Takes the current labels and segmentation in the given database and evaluates perfomance of the segmenter against the hand labels. For each group of labels cells, a false negative if no mask overlaps, false positive if segmented mask overlaps with no group, marginal result if segmented cell overlaps with but is not of of the labeled masks.}{EvaluateSegmentation}
%
\begin{Description}\relax
Takes the current labels and segmentation in the given
database and evaluates perfomance of the segmenter
against the hand labels. For each group of labels cells,
a false negative if no mask overlaps, false positive if
segmented mask overlaps with no group, marginal result if
segmented cell overlaps with but is not of of the labeled
masks.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  EvaluateSegmentation(db)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database for which to evaluate the
segmentation.  should have both a segmentation and hand
labels.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.frame with a row for each class and columns
specifying performance
\end{Value}
\inputencoding{utf8}
\HeaderA{FFTPhaseCor}{INTERNAL Computes sub-pixel shifts values using phase correlation (FFT implementation)}{FFTPhaseCor}
%
\begin{Description}\relax
INTERNAL Computes sub-pixel shifts values using phase
correlation (FFT implementation)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  FFTPhaseCor(img1, img2, upsamp = 2, taper = TRUE,
    cortaper = TRUE, subpixel = "gauss", subrad = 3)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img1}] matrix giving the first image (the
reference)

\item[\code{img2}] matrix giving the second image (to be
shifted)

\item[\code{upsamp}] the factor by which the fft matrix should
be expanded

\item[\code{taper}] boolean, should the images be tapered before
alignment

\item[\code{cortaper}] boolean, should the normalized
cross-spectrum be tapered before being (inverse)
transformed

\item[\code{subpixel}] 'none' for no additional subpixel
fitting, 'gauss' for Gaussian fit, 'poc' for poc function
fitting

\item[\code{subrad}] the radius of the submatrix used to compute
the subpixel fits
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Computes the sub-pixel shifts by computing the upsampled
phase correlation between the two images and finding the
maximum.  If the parameter gausfit is TRUE, then a
gaussian is fit around the peak of the phase correlation
function to get additional sub-pixel shift information.
This is on top of any upsampling
\end{Details}
%
\begin{Value}
a vector of length 2 giving the magnitude of the estimted
x and y shift returns NA in the case of improper input
\end{Value}
\inputencoding{utf8}
\HeaderA{FFTXCor}{INTERNAL Computes sub-pixel shifts values using FFT}{FFTXCor}
%
\begin{Description}\relax
INTERNAL Computes sub-pixel shifts values using FFT
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  FFTXCor(img1, img2, upsamp = 1, taper = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img1}] matrix giving the first image (the
reference)

\item[\code{img2}] matrix giving the second image (to be
shifted)

\item[\code{upsamp}] the factor by which the fft matrix should
be expanded

\item[\code{taper}] number of pixels to taper the data on the
edges of the image
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Computes the sub-pixel shifts by computing the upsampled
cross-correlation between the two images and finding the
maximum. Computes the upsampled cross-correlation by
embedding the product of FT(img1)* and FFT(img2) in a
larger matrix of 0's determined by the upsampling factor.
\end{Details}
%
\begin{Value}
a vector of length 2 giving the magnitude of the estimted
x and y shift returns NA in the case of improper input
\end{Value}
\inputencoding{utf8}
\HeaderA{FilterVector}{INTERNAL Filters a vector by frequency using a butterworth filter}{FilterVector}
%
\begin{Description}\relax
INTERNAL Filters a vector by frequency using a
butterworth filter
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  FilterVector(vec, low, high, order = 8, dt = 0.1247232,
    type = "BP")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec}] the vector to filter

\item[\code{low}] the lower value of the filter

\item[\code{high}] the higher value of the filter

\item[\code{order}] the order of the butterworth filter

\item[\code{dt}] the time (in seconds) of one datapoint.
1/frequency in hz

\item[\code{type}] the type of filter, defaults to "BP" bandpass
filter. Can also choose other filters offered by the
butfilt function
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the filtered vector
\end{Value}
\inputencoding{utf8}
\HeaderA{GetAllSeries}{Get average time series of the given class in the segmentation stored in a mask database}{GetAllSeries}
%
\begin{Description}\relax
Get average time series of the given class in the
segmentation stored in a mask database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetAllSeries(db, calexp, classids, chan = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database

\item[\code{calexp}] the calcium experiment with the data to use
to extract the series

\item[\code{classids}] a vector of ids specifying which types of
ROI to extract traces for

\item[\code{chan}] the channel to use for activity traces
(defaults to 2)
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{GetCliques}{Assigns each of the specified masks to a clique to use when solving the MWIS segmentation}{GetCliques}
%
\begin{Description}\relax
Assigns each of the specified masks to a clique to use
when solving the MWIS segmentation
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetCliques(db, ids, minid = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database

\item[\code{ids}] the vector of ids of the masks to assign to
cliques

\item[\code{minid}] the minimum value of the clique ids to
return
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector giving the clique id for each of the specified
masks
\end{Value}
\inputencoding{utf8}
\HeaderA{GetDataFeatures}{INTERNAL Computes the features related to the data under a mask, adding them to the database}{GetDataFeatures}
%
\begin{Description}\relax
INTERNAL Computes the features related to the data under
a mask, adding them to the database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetDataFeatures(db, data, cormat)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] a database connection

\item[\code{data}] the data array for this experiment

\item[\code{cormat}] the pixel-pixel corrlations for channel 2
for this data
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Computes features of all masks in the database or a list
of masks specified by id.  The features computed are
currently:\\{} var1 - the variance of the pixel means for
channel 1 \\{} var2 - the variance of the pixel means for
channel 2\\{} var1eq - the variance of the pixel means for
the equalized version of channel 1\\{} var2eq - the
variance of the pixel means for the equalized version of
channel 2\\{} mean1eq - the mean of the pixel means for
the equalized version of channel 1\\{} mean2eq - the mean
of the pixel means for the equalized version of channel
2\\{} cor2 - the mean pixel-pixel correlation between the
map pixels in channel 2\\{} cor2min - the min pixel-pixel
correlation between the map pixels in channel 2\\{}
cor2max - the max pixel-pixel correlation between the map
pixels in channel 2\\{}
\end{Details}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{GetExtrema}{Finds the extrema in an image.}{GetExtrema}
%
\begin{Description}\relax
Finds the extrema in an image.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetExtrema(image, maxima = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{image}] the image matrix

\item[\code{maxima}] boolean, should this function find maxima
(default).  If false, finds minima
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with 1 at maxima (or minima) and 0 elsewhere
\end{Value}
\inputencoding{utf8}
\HeaderA{GetInnerMasks}{INTERNAL Selects the masks from the given list that are contained in a region}{GetInnerMasks}
%
\begin{Description}\relax
INTERNAL Selects the masks from the given list that are
contained in a region
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetInnerMasks(framemat, masklist)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{framemat}] a matrix of the same size as the masks in
masklist with non-NA pixels specifying the region in
which to find masks

\item[\code{masklist}] a list of sparse masks (vectors where the
first element is the negative id of the mask and the
other elements are the mask indices)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a list of masks (with negative ids as first
element) and a matrix with a mask specifying a region,
returns the masks in the masklist that are completely
contained in the given region.
\end{Details}
\inputencoding{utf8}
\HeaderA{GetMask}{Return the requested mask from the specified database}{GetMask}
%
\begin{Description}\relax
Return the requested mask from the specified database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetMask(db, id, sparse = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] a database connection

\item[\code{id}] the id of the mask to return

\item[\code{format}] "sparse" for a sparse mask in vector form,
"matrix" for a matrix mask
\end{ldescription}
\end{Arguments}
%
\begin{Value}
either a vector giving the indices of the requested mask
or a matrix version of the mask
\end{Value}
\inputencoding{utf8}
\HeaderA{GetMasks}{Returns a list of the masks in a database}{GetMasks}
%
\begin{Description}\relax
Returns a list of the masks in a database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetMasks(db)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] a database connection
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of vectors, each vector specifying a mask.  The
first element of each mask vector is the negative index
of the mask.  The remaining elements of each vector are
the indices of the mask pixels.
\end{Value}
\inputencoding{utf8}
\HeaderA{GetPhase}{Gets the phase of a given frequency band of a vector using the FFT}{GetPhase}
%
\begin{Description}\relax
Gets the phase of a given frequency band of a vector
using the FFT
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetPhase(vec, low, high, dt = 0.1247232, mag = F)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec}] vector of data

\item[\code{low}] lower bound of frequency band

\item[\code{high}] upper bound of frequency band

\item[\code{dt}] deltaT, or 1/sampling rate
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{GetSegmentation}{Get a matrix giving the segmentation stored in a mask database}{GetSegmentation}
%
\begin{Description}\relax
Get a matrix giving the segmentation stored in a mask
database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetSegmentation(db, classids = c(2, 3), val = "id")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database

\item[\code{classids}] a vector giving the ids of the classes to
include in the returned segmentation

\item[\code{val}] if "id", puts the mask ids in the ROI in the
returned matrix, otherwise uses the class id
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.frame with the extracted data
\end{Value}
\inputencoding{utf8}
\HeaderA{GetSeries}{Return average time series for each cell in a mask}{GetSeries}
%
\begin{Description}\relax
Return average time series for each cell in a mask
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetSeries(mask, calexp, channel = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{calexp}] the calexp with the data

\item[\code{mask}] the mask identifying cells.  Each unique
non-zero/NA value in the mask indicates a cell to be
clustered.

\item[\code{channel}] the channel to get the cell traces from
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{GetShapeFeatures}{INTERNAL Computes the features related to just the shape of masks, adding them to the database}{GetShapeFeatures}
%
\begin{Description}\relax
INTERNAL Computes the features related to just the shape
of masks, adding them to the database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetShapeFeatures(db, mids = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] a database connection

\item[\code{mids}] an optional vector of the mask ids for which
to extract features
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Computes features of all masks in the database or a list
of masks specified by id.  The features computed are
currently:\\{} npixels - the number of pixels in a mask
\\{} nholes - the number of non-mask pixels that are
surrounded by at least 3 mask pixels\\{} bboxratio - the
ratio of the area of the mask's bounding box and the
number of pixels\\{} in the mask hullratio - the ratio of
the area of the mask's convex hull and the number of
pixels in the mask\\{}
\end{Details}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{GetSparseMasks}{Returns a list of the masks in a database}{GetSparseMasks}
%
\begin{Description}\relax
Returns a list of the masks in a database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GetSparseMasks(db)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] a database connection
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a list of vectors, each vector specifying a mask.  The
first element of each mask vector is the negative index
of the mask.  The remaining elements of each vector are
the indices of the mask pixels.
\end{Value}
\inputencoding{utf8}
\HeaderA{GKernel}{Returns a Gaussian kernel}{GKernel}
%
\begin{Description}\relax
Returns a Gaussian kernel
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GKernel(kdim, sigma)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{kdim}] the dimension of the (square) kernel to
generate

\item[\code{sigma}] the standard deviation of the gaussian
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix giving the Gaussian kernel
\end{Value}
\inputencoding{utf8}
\HeaderA{GrpRFCreate}{Creates and trains a custom random forest classifier}{GrpRFCreate}
%
\begin{Description}\relax
Creates and trains a custom random forest classifier
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  GrpRFCreate(labels, groups, data)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{labels}] a vector giving the labels of the training
data.  this should be a factor

\item[\code{groups}] a vector giving the grouping of the
training data.  Any data points the same group value are
treated as members of the same group.

\item[\code{data}] a data.frame giving the training data
features
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{HillClimbC}{INTERNAL Perform hill climbing on a matrix starting from a given point and returning the local maxima that is reached.}{HillClimbC}
%
\begin{Description}\relax
INTERNAL Perform hill climbing on a matrix starting from
a given point and returning the local maxima that is
reached.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  HillClimbC(y, x, img)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] Starting row

\item[\code{x}] Starting column

\item[\code{img}] The matrix on which to performt the
hillclimbing
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses C code in hillclimbC.c
\end{Details}
%
\begin{Value}
a vector of 2 numbers giving the coordinates of the peak
found by hillclimbing
\end{Value}
\inputencoding{utf8}
\HeaderA{HistEqualC}{INTERNAL Computed the histogram equalization of a matrix.}{HistEqualC}
%
\begin{Description}\relax
INTERNAL Computed the histogram equalization of a matrix.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  HistEqualC(mat, fullmax = 4096)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] the matrix to equalize

\item[\code{fullmax}] the range to equalize to
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses C code in histequalC.c
\end{Details}
%
\begin{Value}
the equalized matrix
\end{Value}
\inputencoding{utf8}
\HeaderA{Image}{Plots an image of the given matrix with the origin in the upper left}{Image}
%
\begin{Description}\relax
Plots an image of the given matrix with the origin in the
upper left
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  Image(img, col = grey(seq(0, 1, 0.001)), ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img}] the image matrix to plot

\item[\code{col}] a list of colors to use for plotting, defaults
to grey

\item[\code{...}] additional graphing parameters
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{ImageDb}{Plot an image from a mask database}{ImageDb}
%
\begin{Description}\relax
Plot an image from a mask database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ImageDb(db, imagetag = "mimg2")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database

\item[\code{imagetag}] the tag of the image as stored in the
database
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{ImageToCoordMat}{INTERNAL Converts an image matrix to a matrix with coordinates and values in the columns}{ImageToCoordMat}
%
\begin{Description}\relax
INTERNAL Converts an image matrix to a matrix with
coordinates and values in the columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ImageToCoordMat(img)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img}] the matrix to convert
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of size npixels-by-3. The first coordinate is
the row, the the column and the third the intensity.
\end{Value}
\inputencoding{utf8}
\HeaderA{InitiateMaskClassifier}{Creates a mask classifier based on the given training data}{InitiateMaskClassifier}
%
\begin{Description}\relax
Creates a mask classifier based on the given training
data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  InitiateMaskClassifier(trainingdata)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{trainingdata}] the training data, as returned by
PullAllData or PullData
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a mask classifier
\end{Value}
\inputencoding{utf8}
\HeaderA{IntensityCorrection}{Performs intensity correction on the given calcium experiment}{IntensityCorrection}
%
\begin{Description}\relax
Performs intensity correction on the given calcium
experiment
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  IntensityCorrection(calexp, cortype = "ar", order = 25,
    naclip = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{calexp}] the data to be corrected is in the \$data
element of this calexp object

\item[\code{cortype}] the type of correction to perform.  `ar`
for autoregressive filter

\item[\code{order}] the order of the model to fit (for ar type)

\item[\code{naclip}] should NAs produced at the beginning of the
experiment be clipped off (by AR model, for instance)
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{InvertMask}{INTERNAL Inverts a mask matrix so that the mask region is turned to backgroun and vice versa}{InvertMask}
%
\begin{Description}\relax
INTERNAL Inverts a mask matrix so that the mask region is
turned to backgroun and vice versa
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  InvertMask(mask)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mask}] the mask matrix to invert, with NA in the
background
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with the inverted mask
\end{Value}
\inputencoding{utf8}
\HeaderA{LoGKernel}{Returns a Laplacian of Gaussian kernel}{LoGKernel}
%
\begin{Description}\relax
Returns a Laplacian of Gaussian kernel
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  LoGKernel(kdim, sigma)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{kdim}] the dimension of the (square) kernel to
generate

\item[\code{sigma}] the standard deviation of the gaussian
smoother
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix giving the LoG kernel
\end{Value}
\inputencoding{utf8}
\HeaderA{LoGMasks}{Generates a set of masks using the Laplacian of Gaussian technique for the given scale and kernel size}{LoGMasks}
%
\begin{Description}\relax
Generates a set of masks using the Laplacian of Gaussian
technique for the given scale and kernel size
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  LoGMasks(image, scale, ksize = 15, sparse = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{image}] the image to use to generate masks

\item[\code{scale}] the scale of the kernel to use

\item[\code{kside}] the size of the kernel

\item[\code{sparse}] boolean, should the function return sparse
masks instead of a matrix for plotting
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix with unique integers at mask locations and 0 in
the background, or a a sparse masks object
\end{Value}
\inputencoding{utf8}
\HeaderA{LogSeq}{Generate a sequence with log scale jumps}{LogSeq}
%
\begin{Description}\relax
Generate a sequence with log scale jumps
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  LogSeq(minv, maxv, length.out)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{minv}] the value at the low end of the scale.  This
is set to 0.01 if it is <=0

\item[\code{maxv}] the value at the high end of the scale

\item[\code{length.out}] the number of values to return
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector with the requested sequence
\end{Value}
\inputencoding{utf8}
\HeaderA{MaskDbSetup}{INTERNAL Creates an empty mask database with the appropriate tables}{MaskDbSetup}
%
\begin{Description}\relax
INTERNAL Creates an empty mask database with the
appropriate tables
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  MaskDbSetup(db, calexp, tag, dt = NA, description = NA,
    datafile = NA)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database object for which to create the
mask tables
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{MaskHull}{INTERNAL Computes the convex hull of a mask}{MaskHull}
%
\begin{Description}\relax
INTERNAL Computes the convex hull of a mask
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  MaskHull(sparsemask, nr, nc)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sparsemask}] the sparse mask (vector) for which to
find the convex hull.

\item[\code{nr}] the number of rows in the image

\item[\code{nc}] the number of columns in the image
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
FIXME: there's the issue that
maphull(maphull(x))!=maphull(x), but using this anyway
\end{Details}
%
\begin{Value}
a sparse representation of the convex hull of the given
mask
\end{Value}
\inputencoding{utf8}
\HeaderA{MatrixToSparse}{INTERNAL Converts a matrix to a sparse mask}{MatrixToSparse}
%
\begin{Description}\relax
INTERNAL Converts a matrix to a sparse mask
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  MatrixToSparse(mat)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] the matrix to convert
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list of indices representing the mask
\end{Value}
\inputencoding{utf8}
\HeaderA{MatrixToSparseMasks}{Converts a matrix with unique positive integers on each mask into a sparse mask list}{MatrixToSparseMasks}
%
\begin{Description}\relax
Converts a matrix with unique positive integers on each
mask into a sparse mask list
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  MatrixToSparseMasks(maskmat)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{maskmat}] the matrix with unique integers on each
mask

\item[\code{return}] a sparsemasks object with a list of masks
in the \$masks element and the dimensions of the original
image in the \$dims element
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{MultiTaperSpectrum}{Uses multi-taper methods to etimate a spectrum for the given vector}{MultiTaperSpectrum}
%
\begin{Description}\relax
Uses multi-taper methods to etimate a spectrum for the
given vector
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  MultiTaperSpectrum(vec, dt = 0.1247232, dif = T)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec}] the vector of data

\item[\code{dt}] deltaT, or 1/sampling rate

\item[\code{dif}] boolean, should the vector be differenced
before estimating the spectrum
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{OptimRotate}{INTERNAL Uses optimization of an objective function to compute the best alignment rotation between two images}{OptimRotate}
%
\begin{Description}\relax
INTERNAL Uses optimization of an objective function to
compute the best alignment rotation between two images
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  OptimRotate(img1, img2, taper = TRUE, error = "mse",
    searchrange = c(-0.1, 0.1))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img1}] the reference image

\item[\code{img2}] the image to align

\item[\code{taper}] should the images be tapered before the
rotation is computed (hanning window)

\item[\code{error}] objective function to be used - "mse" mean
squared error, "mae" mean absolute error, "cor"
correlation

\item[\code{searchrange}] the range of rotations to search over
in the optimization
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a real valued estimate of the optimal alignment rotation
\end{Value}
\inputencoding{utf8}
\HeaderA{OptimShift}{INTERNAL Computes the rigid body motion alignment parameters by optimizing some error function comparing the two images. (uses optimization routines in the neldermead package)}{OptimShift}
%
\begin{Description}\relax
INTERNAL Computes the rigid body motion alignment
parameters by optimizing some error function comparing
the two images. (uses optimization routines in the
neldermead package)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  OptimShift(img1, img2, taper = TRUE, error = "mse",
    startval = c(0.1, 0.1, 0), pocstart = TRUE,
    bigsize = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img1}] the reference image

\item[\code{img2}] the image to align

\item[\code{taper}] boolean, should the images be tapered before
aligning

\item[\code{bigsize}] the size of the array in which to embed
the tapered images (defaults to next power of 2)

\item[\code{error}] the error function to use. Can be "mse" for
mean squared error, mae" for mean absolute error, or
"cor" for correlation.

\item[\code{startval}] a length 3 vector giving the inital
values for the optimization (xshift, yshift, theta)

\item[\code{pocstart}] should the POC method be used to
initialize the start values
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a vector of length 3 giving the translation and rotation
estimates
\end{Value}
\inputencoding{utf8}
\HeaderA{OptimTranslate}{Uses optimization of an objective function to compute the best alignment translation between two images (uses optimization routines in the neldermead package)}{OptimTranslate}
%
\begin{Description}\relax
Uses optimization of an objective function to compute the
best alignment translation between two images (uses
optimization routines in the neldermead package)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  OptimTranslate(img1, img2, taper = TRUE, error = "mse",
    startval = c(0.1, 0.1), bigsize = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img1}] the reference image

\item[\code{img2}] the image to align

\item[\code{taper}] should the images be tapered before the
rotation is computed (hanning window)

\item[\code{error}] objective function to be used - "mse" mean
squared error, "mae" mean absolute error, "cor"
correlation

\item[\code{startval}] the inital estimate of the shift
parameters
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a real valued vector of length 2, giving estimates of x
and y translation
\end{Value}
\inputencoding{utf8}
\HeaderA{PhaseDist}{Compute circular phase distance between two phases}{PhaseDist}
%
\begin{Description}\relax
Compute circular phase distance between two phases
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PhaseDist(phase1, phase2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{phase1}] a phase value in [-pi,pi]

\item[\code{phase2}] a phase value in [-pi,pi]
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the circular distance between the two phases
\end{Value}
\inputencoding{utf8}
\HeaderA{PhaseDistMat}{Get phase distance matrix}{PhaseDistMat}
%
\begin{Description}\relax
Get phase distance matrix
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PhaseDistMat(mat, low = 0.789, high = 0.791,
    dt = 0.1247232)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] a matrix with the calcium traces on the
columns

\item[\code{low}] the lower bound of the frequency to consider

\item[\code{high}] the upper bound of the frequency to consider

\item[\code{dt}] the sampling rate of the calcium traces
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a matrix of phase distances between the calcium traces
\end{Value}
\inputencoding{utf8}
\HeaderA{plot.MTSpectrum}{Plots a multitaper spectral estimate created by MultiTaperSpectrum}{plot.MTSpectrum}
%
\begin{Description}\relax
Plots a multitaper spectral estimate created by
MultiTaperSpectrum
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  plot.MTSpectrum(spect, maglog = TRUE, minfreq = 0,
    maxfreq = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{spect}] the multitaper spectrum object

\item[\code{maglog}] should the magnitide be plotted on the log
scale

\item[\code{minfreq}] the minimum frequency to plot

\item[\code{maxfreq}] the maximum frequency to plot (NULL for
Nyquist frequency)

\item[\code{...}] other graphical parameters
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{PlotClustering}{Plots a given clustering}{PlotClustering}
%
\begin{Description}\relax
Plots a given clustering
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PlotClustering(db, ids, clust, chan = 2,
    cols = list(c(0, 0, 1), c(0, 1, 0)))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database with the segmentation

\item[\code{ids}] a vector of ids of the masks involved in the
clustering

\item[\code{clust}] a vector with integers indicating the
clusters

\item[\code{chan}] the channel to use as the background image

\item[\code{cols}] a list of vectors of length 3 giving the rgb
values for each cluster
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{PlotMask}{Plots a mask over an already plotted image}{PlotMask}
%
\begin{Description}\relax
Plots a mask over an already plotted image
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PlotMask(mask, rgb = runif(3), alpha = 0.5, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mask}] the specification of the mask

\item[\code{rgb}] a vector of length 3 giving the color of the
mask in RGB (defaults to random)

\item[\code{alpha}] the alpha transparency value of the mask
(between 0 and 1)

\item[\code{...}] additional graphing parameters
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a mask as either a matrix of logicals or a matrix
with 1's on the mask, over-plot a semi-transparent
colored region on an already plotted image.
\end{Details}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{PlotMaskSet}{Plots sets of masks over an already plotted image}{PlotMaskSet}
%
\begin{Description}\relax
Plots sets of masks over an already plotted image
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PlotMaskSet(mask, alpha = 0.5, rgb = NULL, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mask}] the specification of the mask, unique values
for each mask set, and 0 or NA in background

\item[\code{alpha}] the alpha transparency value of the mask
(between 0 and 1)

\item[\code{...}] additional graphing parameters
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a matrix with unique integers for each mask set,
overplot each mask set in a different color (randomly
chosen)
\end{Details}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{PlotMaskSetByID}{Plots masks specified by the given ids}{PlotMaskSetByID}
%
\begin{Description}\relax
Plots masks specified by the given ids
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PlotMaskSetByID(db, ids, rgb = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database

\item[\code{ids}] a vector giving the ids of the masks to plot

\item[\code{rgb}] a vector of length 3 giving the color to plot
the masks
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{PlotSegmentation}{Plots the segmentation of a particular class, as stored in a mask database}{PlotSegmentation}
%
\begin{Description}\relax
Plots the segmentation of a particular class, as stored
in a mask database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PlotSegmentation(db, classid, rgb = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the database

\item[\code{classid}] the class to plot

\item[\code{rgb}] a vector of length 3 giving the color to plot
the masks
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{PredictExperiment}{Predicts an experiment using the classifier and MWIS TODO - this is currently a hack with a heuristic to find cliques.  should really find connected components and solve the MWIS}{PredictExperiment}
%
\begin{Description}\relax
Predicts an experiment using the classifier and MWIS TODO
- this is currently a hack with a heuristic to find
cliques.  should really find connected components and
solve the MWIS
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PredictExperiment(classifier, db, thresh = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{classifier}] the classifier

\item[\code{dn}] the database to predict

\item[\code{enforcelabels}] boolen, should the final
segmentation be forced to correspond to the hand labels
\end{ldescription}
\end{Arguments}
%
\begin{Value}
null, modifies the database
\end{Value}
\inputencoding{utf8}
\HeaderA{PullAllData}{Checks each database in the given directory and pulls any labeled data}{PullAllData}
%
\begin{Description}\relax
Checks each database in the given directory and pulls any
labeled data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PullAllData(directory)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{directory}] the directory to pull data from
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.frame with the extracted data
\end{Value}
\inputencoding{utf8}
\HeaderA{PullData}{Pulls data from a mask database into a data.frame that has one row for each mask with the label, id, and feature values of that mask in the columns}{PullData}
%
\begin{Description}\relax
Pulls data from a mask database into a data.frame that
has one row for each mask with the label, id, and feature
values of that mask in the columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  PullData(db, labeled = TRUE, group = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database object

\item[\code{labeled}] boolean, should the results be restricted
to masks that have been labeled
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a data.frame with the extracted data
\end{Value}
\inputencoding{utf8}
\HeaderA{RegisterCalExp}{Removes in-plane motion effects using rigid body alignment of the image frames}{RegisterCalExp}
%
\begin{Description}\relax
Removes in-plane motion effects using rigid body
alignment of the image frames
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  RegisterCalExp(calexp, refimg, channel = 1,
    bigsize = c(256, 256))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{calexp}] a calexp object with a \bsl{}\$data field

\item[\code{refimg}] a reference image to use for alignment.
Should be the same size as the images in calexp\bsl{}\$data

\item[\code{channel}] the channel to use for alignment
(typically the structual channel)

\item[\code{upsamp}] the upsampling factor (this gives the
sup-pixel precision of 1/upsamp)
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Registers the images in a calexp object by rigid body
image alignment of the images in a particular channel to
the reference image given.  Initial translation
parameters are estimated using Phase-Only correlation.
The parameters are then optimized using Nelder-Mead
optimization of the mean squared error between the
images.
\end{Details}
%
\begin{Value}
a calexp object with a \bsl{}\$registration field.  The \bsl{}\$data
in the returned object has been registered.  The
\bsl{}\$registration field records the details of the estimated
shifts.  \begin{ldescription}
\item[\code{refimg}] the reference image used
\item[\code{mpars}] the estimated shifts. This is a matrix of
size nframes-by-2
\end{ldescription}
\end{Value}
\inputencoding{utf8}
\HeaderA{RemoveMask}{Remove a mask and its feature links from the database}{RemoveMask}
%
\begin{Description}\relax
Remove a mask and its feature links from the database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  RemoveMask(db, id)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database object

\item[\code{id}] the id of the mask to remove
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{ReorderFFT}{INTERNAL Reorders the matrix returned by fft}{ReorderFFT}
%
\begin{Description}\relax
INTERNAL Reorders the matrix returned by fft
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ReorderFFT(mat, inverse = F)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] a matrix of values to reorder

\item[\code{inverse}] if true, takes reordered matrix and
returns to order expected by fft. if false, takes matrix
from fft and reorders it
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Reorders the matrix returned by the R function fft.  The
R function returns the coefficients from
low-to-high-to-low frequencies in both dimensions.  The
reordering puts the low frequencies in the center of the
matrix so that the coefficients go from
high-to-low-to-high in each dimension
\end{Details}
%
\begin{Value}
the reordered matrix
\end{Value}
\inputencoding{utf8}
\HeaderA{RestrictMaskSize}{Removes masks from the database whose size is less than min pixels or greater than max pixels}{RestrictMaskSize}
%
\begin{Description}\relax
Removes masks from the database whose size is less than
min pixels or greater than max pixels
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  RestrictMaskSize(db, minsize = NA, maxsize = NA)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database object

\item[\code{min}] the minimum mask size (pixels) to retain

\item[\code{max}] the maximum mask size (pixels) to retain
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{RotateFFT}{Rotates an image by the given angle using a sequence of Fourier domain shears as described in Eddy 1996.}{RotateFFT}
%
\begin{Description}\relax
Rotates an image by the given angle using a sequence of
Fourier domain shears as described in Eddy 1996.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  RotateFFT(img, theta, fdomain = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img}] the image to rotate

\item[\code{theta}] the angle to rotate the image

\item[\code{fdomain}] is the image given already in the Fourier
domain?  It will be returned in the same domain as given
(passing in the Fourier domain is helpful to reduce
superfluous transforms if performing additional
operations in the Fourier domain).
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{RotateImg}{INTERNAL Rotates an image by a given number of integer rows and columns}{RotateImg}
%
\begin{Description}\relax
INTERNAL Rotates an image by a given number of integer
rows and columns
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  RotateImg(mat, x, y)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] the matrix to rotate

\item[\code{x}] the number of columns to rotate

\item[\code{y}] the number of rows to rotate
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the rotated matrix
\end{Value}
\inputencoding{utf8}
\HeaderA{SetMaskLabel}{Sets the label field for a particular mask in a mask database}{SetMaskLabel}
%
\begin{Description}\relax
Sets the label field for a particular mask in a mask
database
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  SetMaskLabel(db, id, label)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] a database connection

\item[\code{id}] the id of the mask to label

\item[\code{label}] the label to assign to the mask (0=unknown,
1=cell, 2=not cell)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{ShiftFFT}{Shifts an image by the given amount, both translation and rotation}{ShiftFFT}
%
\begin{Description}\relax
Shifts an image by the given amount, both translation and
rotation
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ShiftFFT(img, pars, fdomain = FALSE, rotatefirst = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img}] the image to shift

\item[\code{pars}] a length-3 vector giving (x-translation,
y-translation, rotation angle)

\item[\code{fdomain}] is the image given in the Fourier domain?
It will be returned in the same domain as given (passing
in the Fourier domain is helpful to reduce superfluous
transforms if performing additional operations in the
Fourier domain).

\item[\code{rotatefirst}] should rotation be performed before
translation
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses RotateFFT and TranslateFFT to compute result
\end{Details}
%
\begin{Value}
the shifted image
\end{Value}
\inputencoding{utf8}
\HeaderA{ShiftFFTVector}{INTERNAL Shifts a vector by the specified amount using FFT phase shift, but assuming the Fourier transform has already been performed.}{ShiftFFTVector}
%
\begin{Description}\relax
INTERNAL Shifts a vector by the specified amount using
FFT phase shift, but assuming the Fourier transform has
already been performed.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ShiftFFTVector(vec, amt)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec}] the vector to shift

\item[\code{amt}] the amount to shift
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the circularly shifted vector
\end{Value}
\inputencoding{utf8}
\HeaderA{ShiftVector}{INTERNAL Shifts a vector by the specified amount using FFT}{ShiftVector}
%
\begin{Description}\relax
INTERNAL Shifts a vector by the specified amount using
FFT
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ShiftVector(vec, amt)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vec}] the vector to shift

\item[\code{amt}] the amount to shift
\end{ldescription}
\end{Arguments}
%
\begin{Value}
the circularly shifted vector
\end{Value}
\inputencoding{utf8}
\HeaderA{SimpleModesC}{INTERNAL Finds the local maxima in an image}{SimpleModesC}
%
\begin{Description}\relax
INTERNAL Finds the local maxima in an image
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  SimpleModesC(img, min = 0)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img}] the image in which to find the local maxima

\item[\code{min}] if this is set to 1, find local minima
instead
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses C code in localmaxC.c
\end{Details}
%
\begin{Value}
matrix with 1 at the maxima and NA elsewhere
\end{Value}
\inputencoding{utf8}
\HeaderA{SlidingHistEqualC}{INTERNAL Computes the sliding window histogram equalization of a matrix}{SlidingHistEqualC}
%
\begin{Description}\relax
INTERNAL Computes the sliding window histogram
equalization of a matrix
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  SlidingHistEqualC(mat, radius, fullmax = 4096)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mat}] the matrix to equalize

\item[\code{radius}] the radius of the sliding window (total
window size is a square window with sides 2*radius+1)

\item[\code{fullmax}] the maximum value in the equalized image
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses C code in slidinghistequalC.c
\end{Details}
%
\begin{Value}
The equalized matrix
\end{Value}
\inputencoding{utf8}
\HeaderA{SparseToMatrix}{INTERNAL Converts a sparse mask to a matrix mask}{SparseToMatrix}
%
\begin{Description}\relax
INTERNAL Converts a sparse mask to a matrix mask
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  SparseToMatrix(sm, ny = 126, nx = 126, background = NA)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{sm}] the sparse representation of the mask (a vector
whose positive values are the indices of the mask
pixels)

\item[\code{ny}] the number of rows of the matrix mask

\item[\code{nx}] the number of columbs of the matrix mask

\item[\code{background}] the value to put in the non-mask pixels
of the matrix
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A matrix of dimension (ny, nx) with 1's in the mask
pixels and background elsewhere
\end{Value}
\inputencoding{utf8}
\HeaderA{summary.MaskDb}{Summary function to quickly see the details/statistics of a mask database object}{summary.MaskDb}
%
\begin{Description}\relax
Summary function to quickly see the details/statistics of
a mask database object
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  summary.MaskDb(db, flag = "default")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] the mask database option

\item[\code{flag}] type of summary to give
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\inputencoding{utf8}
\HeaderA{TranslateFFT}{Shifts an image by the given (fractional pixel) amounts}{TranslateFFT}
%
\begin{Description}\relax
Shifts an image by the given (fractional pixel) amounts
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  TranslateFFT(img, xshift, yshift, fdomain = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{img}] the image (matrix) to shift

\item[\code{xshift}] the amount to shift the in x dimension
(columns)

\item[\code{yshift}] the amount to shift in the y dimension
(rows)

\item[\code{fdomain}] is the image given in the Fourier domain?
It will be returned in the same domain as given (passing
in the Fourier domain is helpful to reduce superfluous
transforms if performing additional operations in the
Fourier domain).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Uses the shift theorem to shift the given image by
transforming to the Fourier domain.  The shift can be
sub-pixel, resulting in Fourier interpolation.
\end{Details}
%
\begin{Value}
the shifted image (matrix)
\end{Value}
\inputencoding{utf8}
\HeaderA{ViewCI}{Opens the GUI viewer to manipulate the segmentation process.}{ViewCI}
%
\begin{Description}\relax
Opens the GUI viewer to manipulate the segmentation
process.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
  ViewCI(db, cf = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{db}] if specified, the viewer opens with the given
dbController (looking in the directories stored in that
object)

\item[\code{cf}] a classifier object.  Needed to allow redoing
segmentation after correcting labels
\end{ldescription}
\end{Arguments}
%
\begin{Value}
NULL
\end{Value}
\printindex{}
\end{document}
